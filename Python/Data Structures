What is a Data Structure? 
A data structure is a specialized format for organizing, processing, retrieving and storing data.
Data Structures allows you to organize your data in such a way that enables you to store collections of data, relate them and perform operations on them accordingly.
It is one of the most basic concepts that beginners get to know about when learning the best Python course online for exams  like PCEP, PCAP, PCPP.   



Types of Data Structures in Python
Python has implicit support for Data Structures which enable you to store and access data. These structures are called List, Dictionary, Tuple and Set.

Python allows its users to create their own Data Structures enabling them to have full control over their functionality. 
The most prominent Data Structures are Stack, Queue, Tree, Linked List and so on which are also available to you in other programming languages.
So now that you know what are the types available to you, why don’t we move ahead to the Data Structures and implement them using Python.



Built-in Data Structures


Lists
Lists are used to store data of different data types in a sequential manner. 
There are addresses assigned to every element of the list, which is called as Index.
The index value starts from 0 and goes on until the last element called the positive index.
There is also negative indexing which starts from -1 enabling you to access elements from the last to first. 

Creating a list
To create a list, you use the square brackets and add elements into it accordingly. 
If you do not pass any elements inside the square brackets, you get an empty list as the output.

1
2
3
4
my_list = [] #create empty list
print(my_list)
my_list = [1, 2, 3, 'example', 3.132] #creating list with data
print(my_list)
Output:
[]
[1, 2, 3, ‘example’, 3.132]

Adding Elements
Adding the elements in the list can be achieved using the append(), extend() and insert() functions.

The append() function adds all the elements passed to it as a single element.
The extend() function adds the elements one-by-one into the list.
The insert() function adds the element passed to the index value and increase the size of the list too.
1
2
3
4
5
6
7
8
my_list = [1, 2, 3]
print(my_list)
my_list.append([555, 12]) #add as a single element
print(my_list)
my_list.extend([234, 'more_example']) #add as different elements
print(my_list)
my_list.insert(1, 'insert_example') #add element i
print(my_list)
Output:
[1, 2, 3]
[1, 2, 3, [555, 12]]
[1, 2, 3, [555, 12], 234, ‘more_example’]
[1, ‘insert_example’, 2, 3, [555, 12], 234, ‘more_example’]

Upskill for Higher Salary with Python Programming Courses
Course Name

Upcoming Batches

Fees

Python Certification Course	20th April 2024 (Weekend Batch)	₹17,795
Python Certification Course	18th May 2024 (Weekend Batch)	₹15,125
Deleting Elements
To delete elements, use the del keyword which is built-in into Python but this does not return anything back to us.
If you want the element back, you use the pop() function which takes the index value.
To remove an element by its value, you use the remove() function.
Example:

1
2
3
4
5
6
7
8
9
my_list = [1, 2, 3, 'example', 3.132, 10, 30]
del my_list[5] #delete element at index 5
print(my_list)
my_list.remove('example') #remove element with value
print(my_list)
a = my_list.pop(1) #pop element from list
print('Popped Element: ', a, ' List remaining: ', my_list)
my_list.clear() #empty the list
print(my_list)
Output:
[1, 2, 3, ‘example’, 3.132, 30]
[1, 2, 3, 3.132, 30]
Popped Element: 2 List remaining: [1, 3, 3.132, 30]
[]

Accessing Elements
Accessing elements is the same as accessing Strings in Python. You pass the index values and hence can obtain the values as needed.

1
2
3
4
5
6
7
my_list = [1, 2, 3, 'example', 3.132, 10, 30]
for element in my_list: #access elements one by one
    print(element)
print(my_list) #access all elements
print(my_list[3]) #access index 3 element
print(my_list[0:2]) #access elements from 0 to 1 and exclude 2
print(my_list[::-1]) #access elements in reverse
Output:
1
2
3
example
3.132
10
30
[1, 2, 3, ‘example’, 3.132, 10, 30]
example
[1, 2]
[30, 10, 3.132, ‘example’, 3, 2, 1]

Other Functions
You have several other functions that can be used when working with lists.

The len() function returns to us the length of the list.
The index() function finds the index value of value passed where it has been encountered the first time.
The count() function finds the count of the value passed to it.
The sorted() and sort() functions do the same thing, that is to sort the values of the list. The sorted() has a return type whereas the sort() modifies the original list.
1
2
3
4
5
6
7
my_list = [1, 2, 3, 10, 30, 10]
print(len(my_list)) #find length of list
print(my_list.index(10)) #find index of element that occurs first
print(my_list.count(10)) #find count of the element
print(sorted(my_list)) #print sorted list but not change original
my_list.sort(reverse=True) #sort original list
print(my_list)
Output:
6
3
2
[1, 2, 3, 10, 10, 30]
[30, 10, 10, 3, 2, 1]
String 

A string is a sequence of characters in Python used to represent text. Strings are immutable, meaning they cannot be changed after they are created.

Creating a String:
Creating a string is as easy as enclosing characters in single or double quotes.

1
2
my_string = "Hello, World!"
print(my_string) # Output: Hello, World!
String Operations:
Concatenation: Joining two or more strings together.

str1 = “Hello”
str2 = “Python”
result = str1 + ” ” + str2
print(result)  
Output: Hello Python
 

Repetition: Repeating a string multiple times.

repeated = “Hi! ” * 3
print(repeated)  
Output: Hi! Hi! Hi!
 

Slicing: Extracting a portion of a string using index positions.

text = “Programming”
print(text[0:5])  
Output: Progr
 

Length: Finding the number of characters in a string.

print(len(text))
Output: 11
 

Changing Case: Convert a string to uppercase or lowercase.

print(text.upper())
Output: PROGRAMMING
 

ByteArray 

A bytearray in Python is a mutable sequence of bytes. It allows you to work with binary data and modify the bytes directly. It’s similar to a list of integers where each integer represents a byte (0 to 255).

 

Example: Creating, Modifying, and Adding Elements to a bytearray
 

# Creating a bytearray from a string

1
2
3
4
5
6
7
8
9
10
11
12
13
data = bytearray("Hello", 'utf-8')
print("Original bytearray:", data.decode('utf-8')) 
# Output: Hello
# Modifying the first byte (H -> J)
data[0] = ord('J')
print("After modification:", data.decode('utf-8')) 
# Output: Jello
# Adding a single byte ('!')
data.append(ord('!'))
# Extending the bytearray with another byte sequence (' World')
data.extend(bytearray(" World", 'utf-8'))
# Final output
print("Final bytearray:", data.decode('utf-8')) # Output: Jello! World
Output:
Original bytearray: Hello

After modification: Jello

Final bytearray: Jello! World

This example covers the creation, modification, and addition of elements to a bytearray.

 

Collections Module:

 

The collections module in Python provides specialized container data types that extend the functionality of built-in types like lists, dictionaries, and tuples.

Here are some key data structures from the collections module, along with code examples and its output:

 

Counter

Counter is a subclass of dict used to count hashable objects. It counts the frequency of elements in an iterable.

from collections import Counter

# Example: Count frequencies of characters in a string

1
2
3
data = "apple"
counter = Counter(data)
print(counter)
Output:

Counter({‘p’: 2, ‘a’: 1, ‘l’: 1, ‘e’: 1})

 

OrderedDict

Course Curriculum
Python Scripting Certification Training
Self-Paced LearningReal-life Case StudiesAssignmentsLifetime Access
OrderedDict is a dictionary subclass that remembers the order in which keys were inserted.

from collections import OrderedDict

# Example: Create an ordered dictionary

1
2
3
4
5
ordered_dict = OrderedDict()
ordered_dict['first'] = 1
ordered_dict['second'] = 2
ordered_dict['third'] = 3
print(ordered_dict)
Output:

OrderedDict([(‘first’, 1), (‘second’, 2), (‘third’, 3)])

 

Defaultdict

defaultdict is a dictionary that returns a default value if the key is not found. You can specify the default type (like int, list, etc.).

from collections import defaultdict

# Example: defaultdict with int (default value 0)

1
2
3
4
dd = defaultdict(int)
dd['a'] += 1
dd['b'] += 2
print(dd)
Output:

defaultdict(<class ‘int’>, {‘a’: 1, ‘b’: 2})

 

ChainMap

ChainMap groups multiple dictionaries into a single view, allowing lookup across dictionaries.

from collections import ChainMap

# Example: Chain two dictionaries

1
2
3
4
5
dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}
chain_map = ChainMap(dict1, dict2)
print(chain_map['b']) # Value from dict1 takes precedence
print(chain_map['c']) # Value from dict2
Output:

2

4

 

NamedTuple

NamedTuple is a lightweight, immutable object that provides named fields for accessing data like a class.

from collections import named tuple

# Example: Create a named tuple for a point in 2D space

1
2
3
Point = namedtuple('Point', ['x', 'y'])
p = Point(10, 20)
print(p.x, p.y)
Output:

10 20

 

Dict

dict is the built-in Python dictionary, a mutable data type used to store key-value pairs.

 

# Example: Basic dictionary usage

1
2
3
4
dict_example = {'name': 'Alice', 'age': 25}
print(dict_example['name'])
dict_example['age'] = 26
print(dict_example)
Output:

Alice

{‘name’: ‘Alice’, ‘age’: 26}

These are some of the most commonly used data structures from the collections module in 

 

Python. Each offers specialized functionality to simplify certain tasks in Python programming.

 

UserDict

UserDict is a wrapper around the regular dictionary (dict) that makes it easier to subclass and customize dictionary behavior.

 

from collections import UserDict

# Example: Custom dictionary that converts keys to uppercase

1
2
3
4
5
6
class MyDict(UserDict):
def __setitem__(self, key, value):
super().__setitem__(key.upper(), value)
my_dict = MyDict()
my_dict['name'] = 'Alice'
print(my_dict)
Output:

{‘NAME’: ‘Alice’}

 

UserList

UserList is a wrapper around the standard list that allows you to modify list behavior when subclassing.

 

from collections import UserList

# Example: Custom list that prevents adding negative numbers

1
2
3
4
5
6
7
8
class MyList(UserList):
def append(self, item):
if item >= 0:
 super().append(item)
my_list = MyList()
my_list.append(10)
my_list.append(-5)
print(my_list)
Output:

[10]

 

UserString

UserString is a wrapper around the standard string (str) that makes it easier to subclass and extend string behavior.

 

from collections import UserString

# Example: Custom string that converts to lowercase

Programming & Frameworks Training
1
2
3
4
5
class MyString(UserString):
def __init__(self, data):
super().__init__(data.lower())
my_string = MyString("HELLO WORLD")
print(my_string)
Output:

hello world

 

These classes make it easier to create custom objects that behave like built-in data types but with added functionality.

Dictionary
Dictionaries are used to store key-value pairs. To understand better, think of a phone directory where hundreds and thousands of names and their corresponding numbers have been added. Now the constant values here are Name and the Phone Numbers which are called as the keys. And the various names and phone numbers are the values that have been fed to the keys. If you access the values of the keys, you will obtain all the names and phone numbers. So that is what a key-value pair is. And in Python, this structure is stored using Dictionaries. Let us understand this better with an example program.

Creating a Dictionary
Dictionaries can be created using the flower braces or using the dict() function. You need to add the key-value pairs whenever you work with dictionaries.

1
2
3
4
my_dict = {} #empty dictionary
print(my_dict)
my_dict = {1: 'Python', 2: 'Java'} #dictionary with elements
print(my_dict)
Output:
{}
{1: ‘Python’, 2: ‘Java’}

Changing and Adding key, value pairs
To change the values of the dictionary, you need to do that using the keys. So, you firstly access the key and then change the value accordingly. To add values, you simply just add another key-value pair as shown below.

1
2
3
4
5
6
my_dict = {'First': 'Python', 'Second': 'Java'}
print(my_dict)
my_dict['Second'] = 'C++' #changing element
print(my_dict)
my_dict['Third'] = 'Ruby' #adding key-value pair
print(my_dict)
Output:
{‘First’: ‘Python’, ‘Second’: ‘Java’}
{‘First’: ‘Python’, ‘Second’: ‘C++’}
{‘First’: ‘Python’, ‘Second’: ‘C++’, ‘Third’: ‘Ruby’}

Deleting key, value pairs
To delete the values, you use the pop() function which returns the value that has been deleted.
To retrieve the key-value pair, you use the popitem() function which returns a tuple of the key and value.
To clear the entire dictionary, you use the clear() function.
1
2
3
4
5
6
7
8
9
my_dict = {'First': 'Python', 'Second': 'Java', 'Third': 'Ruby'}
a = my_dict.pop('Third') #pop element
print('Value:', a)
print('Dictionary:', my_dict)
b = my_dict.popitem() #pop the key-value pair
print('Key, value pair:', b)
print('Dictionary', my_dict)
my_dict.clear() #empty dictionary
print('n', my_dict)
Output:

Value: Ruby
Dictionary: {‘First’: ‘Python’, ‘Second’: ‘Java’}

Key, value pair: (‘Second’, ‘Java’)
Dictionary {‘First’: ‘Python’}

{}

Accessing Elements
You can access elements using the keys only. You can use either the get() function or just pass the key values and you will be retrieving the values.

1
2
3
my_dict = {'First': 'Python', 'Second': 'Java'}
print(my_dict['First']) #access elements using keys
print(my_dict.get('Second'))
Output:
Python
Java

Other Functions
You have different functions which return to us the keys or the values of the key-value pair accordingly to the keys(), values(), items() functions accordingly.

1
2
3
4
5
my_dict = {'First': 'Python', 'Second': 'Java', 'Third': 'Ruby'}
print(my_dict.keys()) #get keys
print(my_dict.values()) #get values
print(my_dict.items()) #get key-value pairs
print(my_dict.get('First'))
Output:
dict_keys([‘First’, ‘Second’, ‘Third’])
dict_values([‘Python’, ‘Java’, ‘Ruby’])
dict_items([(‘First’, ‘Python’), (‘Second’, ‘Java’), (‘Third’, ‘Ruby’)])
Python


Tuple
Tuples are the same as lists are with the exception that the data once entered into the tuple cannot be changed no matter what. The only exception is when the data inside the tuple is mutable, only then the tuple data can be changed. The example program will help you understand better.

Creating a Tuple
You create a tuple using parenthesis or using the tuple() function.

1
2
my_tuple = (1, 2, 3) #create tuple
print(my_tuple) 
Output:
(1, 2, 3)

Accessing Elements
Accessing elements is the same as it is for accessing values in lists.

1
2
3
4
5
6
7
my_tuple2 = (1, 2, 3, 'edureka') #access elements
for x in my_tuple2:
    print(x)
print(my_tuple2)
print(my_tuple2[0])
print(my_tuple2[:])
print(my_tuple2[3][4])
Output:
1
2
3
edureka
(1, 2, 3, ‘edureka’)
1
(1, 2, 3, ‘edureka’)
e

Appending Elements
To append the values, you use the ‘+’ operator which will take another tuple to be appended to it.

1
2
3
my_tuple = (1, 2, 3)
my_tuple = my_tuple + (4, 5, 6) #add elements
print(my_tuple)
Output:
(1, 2, 3, 4, 5, 6)

Other Functions
These functions are the same as they are for lists.

1
2
3
4
5
my_tuple = (1, 2, 3, ['hindi', 'python'])
my_tuple[3][0] = 'english'
print(my_tuple)
print(my_tuple.count(2))
print(my_tuple.index(['english', 'python']))
Output:
(1, 2, 3, [‘english’, ‘python’])
1
3


Sets
Sets are a collection of unordered elements that are unique. Meaning that even if the data is repeated more than one time, it would be entered into the set only once. It resembles the sets that you have learnt in arithmetic. The operations also are the same as is with the arithmetic sets. An example program would help you understand better.

Creating a set
Sets are created using the flower braces but instead of adding key-value pairs, you just pass values to it.

1
2
my_set = {1, 2, 3, 4, 5, 5, 5} #create set
print(my_set)
Output:
{1, 2, 3, 4, 5}

Adding elements
To add elements, you use the add() function and pass the value to it.

1
2
3
my_set = {1, 2, 3}
my_set.add(4) #add element to set
print(my_set)
Output:
{1, 2, 3, 4}

Operations in sets
The different operations on set such as union, intersection and so on are shown below.

1
2
3
4
5
6
7
8
my_set = {1, 2, 3, 4}
my_set_2 = {3, 4, 5, 6}
print(my_set.union(my_set_2), '----------', my_set | my_set_2)
print(my_set.intersection(my_set_2), '----------', my_set & my_set_2)
print(my_set.difference(my_set_2), '----------', my_set - my_set_2)
print(my_set.symmetric_difference(my_set_2), '----------', my_set ^ my_set_2)
my_set.clear()
print(my_set)
The union() function combines the data present in both sets.
The intersection() function finds the data present in both sets only.
The difference() function deletes the data present in both and outputs data present only in the set passed.
The symmetric_difference() does the same as the difference() function but outputs the data which is remaining in both sets.
Output:
{1, 2, 3, 4, 5, 6} ———- {1, 2, 3, 4, 5, 6}
{3, 4} ———- {3, 4}
{1, 2} ———- {1, 2}
{1, 2, 5, 6} ———- {1, 2, 5, 6}
set()

Frozen Set

A frozen set in Python is an immutable version of a regular set, meaning its elements cannot be changed after creation (no adding, removing, or modifying elements). It’s useful when you need a set that should not be altered, like using it as a key in a dictionary.

Creating a Frozen Set:
frozen = frozenset([1, 2, 3, 4])

print(frozen)

Adding Elements:
You cannot add elements to a frozen set after its creation since it’s immutable.

Operations on Frozen Sets:
You can still perform set operations like:

Union: frozen1 | frozen2
Intersection: frozen1 & frozen2
Difference: frozen1 – frozen2
Symmetric Difference: frozen1 ^ frozen2
Example:

frozen1 = frozenset([1, 2, 3])

frozen2 = frozenset([3, 4, 5])

 

# Union

print(frozen1 | frozen2)

 Output: 

frozenset({1, 2, 3, 4, 5})

 

# Intersection

print(frozen1 & frozen2) 

Output: 

frozenset({3})

##################################################################################

User-Defined Data Structures

Arrays vs. Lists
Arrays and lists are the same structure with one difference. 
Lists allow heterogeneous data element storage whereas Arrays allow only homogenous elements to be stored within them.


Stack
Stacks are linear Data Structures which are based on the principle of Last-In-First-Out (LIFO) where data which is entered last will be the first to get accessed. 
It is built using the array structure and has operations namely, pushing (adding) elements, popping (deleting) elements and accessing elements only from one point in the stack called as the TOP.
This TOP is the pointer to the current position of the stack. Stacks are prominently used in applications such as Recursive Programming, reversing words, undo mechanisms in word editors and so for


Queue
A queue is also a linear data structure which is based on the principle of First-In-First-Out (FIFO) where the data entered first will be accessed first.
It is built using the array structure and has operations which can be performed from both ends of the Queue, that is, head-tail or front-back.
Operations such as adding and deleting elements are called En-Queue and De-Queue and accessing the elements can be performed. 
Queues are used as Network Buffers for traffic congestion management, used in Operating Systems for Job Scheduling and many more.


Tree
Trees are non-linear Data Structures which have root and nodes.
The root is the node from where the data originates and the nodes are the other data points that are available to us. 
The node that precedes is the parent and the node after is called the child. There are levels a tree has to show the depth of information. 
The last nodes are called the leaves. Trees create a hierarchy which can be used in a lot of real-world applications such as the HTML pages use trees to distinguish which tag comes under which block.
It is also efficient in searching purposes and much more.



Linked List
Linked lists are linear Data Structures which are not stored consequently but are linked with each other using pointers.
The node of a linked list is composed of data and a pointer called next. 
These structures are most widely used in image viewing applications, music player applications and so forth.

Graph
Graphs are used to store data collection of points called vertices (nodes) and edges (edges). 
Graphs can be called as the most accurate representation of a real-world map.
They are used to find the various cost-to-distance between the various data points called as the nodes and hence find the least path.
Many applications such as Google Maps, Uber, and many more use Graphs to find the least distance and increase profits in the best ways.



HashMaps
HashMaps are the same as what dictionaries are in Python. 
They can be used to implement applications such as phonebooks, populate data according to the lists and much more.


